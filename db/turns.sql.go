// Code generated by sqlc. DO NOT EDIT.
// source: turns.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTurn = `-- name: CreateTurn :execresult
INSERT INTO turns (person_id, date)
VALUES (?, ?)
`

type CreateTurnParams struct {
	PersonID int64     `json:"person_id"`
	Date     time.Time `json:"date"`
}

func (q *Queries) CreateTurn(ctx context.Context, arg CreateTurnParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTurn, arg.PersonID, arg.Date)
}

const deleteTurn = `-- name: DeleteTurn :exec
DELETE
FROM turns
WHERE id = ?
  AND person_id = ?
`

type DeleteTurnParams struct {
	ID       int64 `json:"id"`
	PersonID int64 `json:"person_id"`
}

func (q *Queries) DeleteTurn(ctx context.Context, arg DeleteTurnParams) error {
	_, err := q.db.ExecContext(ctx, deleteTurn, arg.ID, arg.PersonID)
	return err
}

const getTurn = `-- name: GetTurn :one
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE t.id = ?
  AND p.team_id = ?
LIMIT 1
`

type GetTurnParams struct {
	ID     int64 `json:"id"`
	TeamID int64 `json:"team_id"`
}

type GetTurnRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetTurn(ctx context.Context, arg GetTurnParams) (GetTurnRow, error) {
	row := q.db.QueryRowContext(ctx, getTurn, arg.ID, arg.TeamID)
	var i GetTurnRow
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.Date,
		&i.CreatedAt,
	)
	return i, err
}

const getTurnByDate = `-- name: GetTurnByDate :one
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE t.date = ?
  AND p.team_id = ?
LIMIT 1
`

type GetTurnByDateParams struct {
	Date   time.Time `json:"date"`
	TeamID int64     `json:"team_id"`
}

type GetTurnByDateRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetTurnByDate(ctx context.Context, arg GetTurnByDateParams) (GetTurnByDateRow, error) {
	row := q.db.QueryRowContext(ctx, getTurnByDate, arg.Date, arg.TeamID)
	var i GetTurnByDateRow
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.Date,
		&i.CreatedAt,
	)
	return i, err
}

const getTurnByDateAndTeam = `-- name: GetTurnByDateAndTeam :one
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE t.date = ?
  AND p.team_id = ?
LIMIT 1
`

type GetTurnByDateAndTeamParams struct {
	Date   time.Time `json:"date"`
	TeamID int64     `json:"team_id"`
}

type GetTurnByDateAndTeamRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetTurnByDateAndTeam(ctx context.Context, arg GetTurnByDateAndTeamParams) (GetTurnByDateAndTeamRow, error) {
	row := q.db.QueryRowContext(ctx, getTurnByDateAndTeam, arg.Date, arg.TeamID)
	var i GetTurnByDateAndTeamRow
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.Date,
		&i.CreatedAt,
	)
	return i, err
}

const listTurns = `-- name: ListTurns :many
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE p.team_id = ?
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type ListTurnsParams struct {
	TeamID int64 `json:"team_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTurnsRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) ListTurns(ctx context.Context, arg ListTurnsParams) ([]ListTurnsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurns, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTurnsRow{}
	for rows.Next() {
		var i ListTurnsRow
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithBothDates = `-- name: ListTurnsWithBothDates :many
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE p.team_id = ?
  AND t.date >= ?
  AND t.date <= ?
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type ListTurnsWithBothDatesParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListTurnsWithBothDatesRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) ListTurnsWithBothDates(ctx context.Context, arg ListTurnsWithBothDatesParams) ([]ListTurnsWithBothDatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithBothDates,
		arg.TeamID,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTurnsWithBothDatesRow{}
	for rows.Next() {
		var i ListTurnsWithBothDatesRow
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithDateFrom = `-- name: ListTurnsWithDateFrom :many
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE p.team_id = ?
  AND t.date >= ?
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type ListTurnsWithDateFromParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListTurnsWithDateFromRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) ListTurnsWithDateFrom(ctx context.Context, arg ListTurnsWithDateFromParams) ([]ListTurnsWithDateFromRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithDateFrom,
		arg.TeamID,
		arg.Date,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTurnsWithDateFromRow{}
	for rows.Next() {
		var i ListTurnsWithDateFromRow
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithDateTo = `-- name: ListTurnsWithDateTo :many
SELECT t.id, t.person_id, t.date, t.created_at
FROM turns t
         LEFT JOIN people p ON t.person_id = p.id
WHERE p.team_id = ?
  AND t.date <= ?
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type ListTurnsWithDateToParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListTurnsWithDateToRow struct {
	ID        int64        `json:"id"`
	PersonID  int64        `json:"person_id"`
	Date      time.Time    `json:"date"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) ListTurnsWithDateTo(ctx context.Context, arg ListTurnsWithDateToParams) ([]ListTurnsWithDateToRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithDateTo,
		arg.TeamID,
		arg.Date,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTurnsWithDateToRow{}
	for rows.Next() {
		var i ListTurnsWithDateToRow
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTurn = `-- name: UpdateTurn :execresult
UPDATE turns
SET person_id = ?,
    date      = ?
WHERE id = ?
`

type UpdateTurnParams struct {
	PersonID int64     `json:"person_id"`
	Date     time.Time `json:"date"`
	ID       int64     `json:"id"`
}

func (q *Queries) UpdateTurn(ctx context.Context, arg UpdateTurnParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTurn, arg.PersonID, arg.Date, arg.ID)
}
